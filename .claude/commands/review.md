---
description: 审查 Shannon 特定模式、安全性和常见错误的代码更改
---

审查当前更改（暂存或工作目录），重点关注 Shannon 特定模式和常见错误。

## 步骤 1：收集更改
运行这些命令以了解范围：
```bash
git diff --stat HEAD
git diff HEAD
```

## 步骤 2：检查 Shannon 特定模式

### 错误处理（关键）
- [ ] **所有错误使用 PentestError** - 永远不要使用原始的 `Error`。使用 `new PentestError(message, type, retryable, context)`
- [ ] **错误类型适当** - 使用正确的类型：'config', 'network', 'tool', 'prompt', 'filesystem', 'validation', 'billing', 'unknown'
- [ ] **可重试标志匹配行为** - 如果错误将被重试，设置 `retryable: true`
- [ ] **上下文包含调试信息** - 向上下文对象添加相关路径、工具名称、错误代码
- [ ] **永远不要静默吞噬错误** - 始终记录或传播错误

### 审计系统和并发（关键）
- [ ] **并行操作的互斥锁保护** - 在并行智能体执行期间更新 `session.json` 时使用 `sessionMutex.lock()`
- [ ] **修改前重新加载** - 在互斥锁块中更新指标前始终调用 `this.metricsTracker.reload()`
- [ ] **session.json 的原子写入** - 对会话元数据使用 `atomicWrite()`，永远不要直接使用 `fs.writeFile()`
- [ ] **流排水处理** - 日志写入必须等待缓冲区排水后再解析
- [ ] **finally 中的信号量释放** - Git 信号量必须在 `finally` 块中释放

### Claude SDK 集成（关键）
- [ ] **MCP 服务器配置** - 验证 Playwright MCP 使用 `--isolated` 和唯一的 `--user-data-dir`
- [ ] **提示变量插值** - 检查所有 `{{VARIABLE}}` 占位符是否被替换
- [ ] **回合计数** - 在助手消息上递增 `turnCount`，而不是工具调用
- [ ] **成本跟踪** - 从最终的 `result` 消息中提取成本，即使失败也要跟踪
- [ ] **API 错误检测** - 检查 "会话限制已达到"（致命）与其他错误

### 配置和验证（关键）
- [ ] **YAML 的 FAILSAFE_SCHEMA** - 永远不要使用默认模式（防止代码执行）
- [ ] **安全模式检测** - 检查路径遍历 (`../`)、HTML 注入 (`<>`)、JavaScript URL
- [ ] **规则冲突检测** - 规则不能同时出现在 `avoid` 和 `focus` 中
- [ ] **重复规则检测** - 相同的 `type:url_path` 不能出现两次
- [ ] **使用前的 JSON Schema 验证** - 配置必须通过 AJV 验证

### 会话和智能体管理（关键）
- [ ] **交付物依赖得到尊重** - 只有当漏洞队列存在且有项目时，才运行利用智能体
- [ ] **利用前的队列验证** - 使用 `safeValidateQueueAndDeliverable()` 检查资格
- [ ] **智能体运行前的 Git 检查点** - 为失败时的回滚创建检查点
- [ ] **重试时的 Git 回滚** - 在每次重试尝试前调用 `rollbackGitWorkspace()`
- [ ] **智能体先决条件检查** - 在运行依赖智能体前验证先决条件智能体已完成

### 并行执行
- [ ] **并行智能体使用 Promise.allSettled** - 永远不要使用 `Promise.all`（部分失败不应崩溃批处理）
- [ ] **错开启动** - 并行智能体启动之间 2 秒延迟，防止 API 节流
- [ ] **独立重试循环** - 每个智能体独立重试（最多 3 次尝试）
- [ ] **结果正确聚合** - 处理来自 `Promise.allSettled` 的 'fulfilled' 和 'rejected' 结果

## 步骤 3：TypeScript 安全性

### 类型断言（警告）
- [ ] **无双重转换** - 永远不要使用 `as unknown as SomeType`（绕过类型安全）
- [ ] **转换前验证** - JSON 解析的数据在 `as Type` 前应验证（JSON Schema）
- [ ] **优先使用类型保护** - 尽可能使用 `instanceof` 或属性检查代替断言

### 空值/未定义处理
- [ ] **显式空值检查** - 对关键路径使用 `if (x === null || x === undefined)` 而不是真值检查
- [ ] **空值合并** - 对空值/未定义使用 `??`，而不是 `||`（后者也会捕获空字符串/0）
- [ ] **可选链** - 对可能未定义对象的嵌套属性访问使用 `?.`

### 导入和类型
- [ ] **类型导入** - 对仅类型导入使用 `import type { ... }`
- [ ] **无隐式 any** - 所有函数参数和返回值必须有显式类型
- [ ] **常量使用只读** - 对不可变数据使用 `Object.freeze()` 和 `Readonly<>`

## 步骤 4：安全审查

### 防御性工具安全
- [ ] **日志中无凭据** - 检查密码、令牌、TOTP 密钥未记录到审计文件
- [ ] **配置文件大小限制** - 确保配置文件最大 1MB（防止 DoS）
- [ ] **安全的 shell 执行** - 命令参数必须转义/消毒

### 代码注入预防
- [ ] **YAML 安全解析** - 仅使用 FAILSAFE_SCHEMA
- [ ] **无 eval/Function** - 永远不要使用动态代码评估
- [ ] **边界的输入验证** - URL、路径在使用前验证

## 步骤 5：应避免的常见错误

### 代码库中发现的反模式
- [ ] **无上下文的捕获 + 重新抛出** - 不要只是 `throw error`，用额外上下文包装
- [ ] **会话加载中的静默失败** - 损坏的会话文件应警告用户，而不是静默重置
- [ ] **重复重试逻辑** - 不要在调用者和被调用者级别都实现重试
- [ ] **硬编码错误消息匹配** - 优先使用错误代码而不是对 error.message 使用正则表达式
- [ ] **长时间操作缺少超时** - Git 操作和 API 调用应具有超时

### 代码质量
- [ ] **未添加死代码** - 删除未使用的导入、函数、变量
- [ ] **无过度工程** - 不为单次使用操作添加抽象
- [ ] **仅在需要时添加注释** - 自文档化代码优于过多注释
- [ ] **一致的文件命名** - 文件使用 kebab-case（例如 `queue-validation.ts`）

## 步骤 6：提供反馈

对于发现的每个问题：
1. **位置**：文件和行号
2. **问题**：什么是错误的以及为什么重要
3. **修复**：如何纠正它（如果有帮助，提供代码示例）
4. **严重程度**：关键 / 警告 / 建议

### 严重程度定义
- **关键**：会导致错误、崩溃、数据丢失或安全问题
- **警告**：代码异味、不一致的模式或潜在的未来问题
- **建议**：样式改进或小的增强

总结：
- 按严重程度分类的问题总数
- 总体评估（准备提交 / 需要修复 / 需要讨论）

---

现在审查当前更改。